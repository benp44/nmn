#!/usr/bin/python3

# Network Monitor and Notifier (NMN)

from threading import Thread
from subprocess import check_output, PIPE
from loguru import logger
from time import sleep
from sys import stdout
from signal import signal, SIGINT, SIGTERM, SIG_IGN
from os import setpgrp, mkdir, path

DATA_DIRECTORY = "/tmp/nmn"
NOTIFICATION_DURATION = 6
INTERVAL_QUERY_INTERFACES = 30
INTERVAL_QUERY_FOR_DEVICES = 10


def preexec_function():

    setpgrp()


def get_notification_command():

    return path.dirname(path.realpath(__file__)) + "/notify-send-wrapper/notify-send.sh"


class InterfaceMonitor:

    def __init__(self, interface_name, ip_address_range):

        self._interface_name = interface_name
        self._ip_address_range = ip_address_range
        self._continue_processing = True
        self._complete = False
        self._thread = Thread(target=self._scan_interface_for_changes)
        self._current_notifications = []

    def start_scanning(self):

        logger.info("Starting monitor on " + self._interface_name + "...")
        self._thread.start()

    def stop_scanning(self):

        logger.info("Stopping monitor on " + self._interface_name + "...")
        self._continue_processing = False
        self._thread.join()

    def is_running(self):

        return self._complete is False

    def _on_device_added(self, name, address):

        message = name + " joined the network on " + self._interface_name + " (" + address + ")"
        logger.info(message)
        self.show_notification(address, message, "vcs-added")

    def _on_device_removed(self, name, address):

        message = name + " left the network on " + self._interface_name + " (" + address + ")"
        logger.info(message)
        self.show_notification(address, message, "vcs-removed")

    def show_notification(self, address, message, icon):

        notification_thread = Thread(target=self._show_and_hide_notification, args=(address, message, icon))
        notification_thread.start()

    def make_filename_safe(self, input_string):
        return "".join([c for c in input_string if c.isalpha() or c.isdigit() or c == ' ']).rstrip()

    def _show_and_hide_notification(self, address, message, icon):

        notify_command = get_notification_command()
        replace_file = DATA_DIRECTORY + "/" + self.make_filename_safe(address)

        output = check_output([notify_command, "--print-id", "--app-name=nmn", "--icon=" + icon, "--replace-file=" + replace_file, message])
        output = output.decode("UTF-8").strip()

        logger.debug("notify-send output: " + output)

        if output.isdigit():
            sleep(NOTIFICATION_DURATION)
            logger.debug("Killing notification with id: " + output)
            check_output([notify_command, "--close=" + output])

    def _scan_interface_for_changes(self):

        first_run = True
        known_hosts = {}

        while self._continue_processing:
            try:
                found_hosts = {}

                logger.debug("Running scan on " + self._interface_name + " using " + self._ip_address_range)
                output = check_output(["nmap", "-sn", self._ip_address_range, "-oG", "-"], stdin=PIPE, preexec_fn=preexec_function)
                output = output.decode("UTF-8")
                logger.debug(output)
                lines = output.split("\n")

                for line in lines:
                    if line.startswith("Host:"):
                        parts = line.split()
                        if len(parts) == 5:
                            address = parts[1]
                            hostname = parts[2].replace("(", "").replace(")", "")
                            found_hosts[address] = hostname

                if first_run is False:
                    for address in found_hosts.keys():
                        if address not in known_hosts.keys():
                            name = address
                            if found_hosts[address] != "":
                                name = found_hosts[address]

                            self._on_device_added(name, address)

                    for address in known_hosts.keys():
                        if address not in found_hosts.keys():
                            name = address
                            if known_hosts[address] != "":
                                name = known_hosts[address]

                            self._on_device_removed(name, address)

                known_hosts = found_hosts.copy()

                if first_run is True:
                    logger.info("Initialisation run complete for " + self._interface_name)
                    first_run = False

                for _ in range(INTERVAL_QUERY_FOR_DEVICES):
                    sleep(1)
                    if self._continue_processing is False:
                        break

            except Exception as Error:
                logger.warning(str(Error))
                raise

        self._complete = True


class Application:

    def __init__(self):

        self._continue_running = True
        self._monitors = {}

    def monitor_networks(self):

        known_interfaces = {}

        while self._continue_running:

            found_interfaces = self.list_interfaces()

            for found_interface_name in found_interfaces.keys():
                if found_interface_name not in known_interfaces.keys():
                    ip_address_range = found_interfaces[found_interface_name]
                    new_monitor = InterfaceMonitor(found_interface_name, ip_address_range)
                    new_monitor.start_scanning()
                    self._monitors[found_interface_name] = new_monitor

            for known_interface_name in known_interfaces.keys():
                if known_interface_name not in found_interfaces.keys():
                    monitor = self._monitors[known_interface_name]
                    monitor.stop_scanning()
                    self._monitors.pop(known_interface_name, None)

            known_interfaces = found_interfaces.copy()

            for _ in range(INTERVAL_QUERY_INTERFACES):
                sleep(1)
                if self._continue_running is False:
                    break

    def wind_down(self):

        for monitor in self._monitors.values():
            monitor.stop_scanning()

    def list_interfaces(self):

        interfaces = {}

        logger.debug("Listing interfaces...")
        output = check_output(["ip", "-br", "address", "show"], stdin=PIPE, preexec_fn=preexec_function)
        output = output.decode("UTF-8")
        logger.debug(output)
        lines = output.split("\n")

        for line in lines:
            parts = line.split()
            if len(parts) >= 3:
                if parts[1] == "UP":
                    name = parts[0]
                    ip_address_range = parts[2]
                    interfaces[name] = ip_address_range

        return interfaces

    def setup_logging(self):

        logger.remove()

        if not path.exists(DATA_DIRECTORY):
            mkdir(DATA_DIRECTORY)

        logger.add(DATA_DIRECTORY + "/debug_{time}.log", rotation="5 MB")
        logger.add(DATA_DIRECTORY + "/error_{time}.log", level="ERROR", rotation="5 MB")
        logger.add(stdout, colorize=True, format="<green>{time}</green> <level>{message}</level>", level="INFO")

        logger.info("Starting nmn...")

    def signal_handler(self, signal, frame):

        logger.info("Signal caught. Exiting...")

        self._continue_running = False

    def setup_signal_handling(self):

        signal(SIGINT, self.signal_handler)
        signal(SIGTERM, self.signal_handler)


if path.exists(get_notification_command()) is False:

    print("notify-send.sh was not found. Please clone submodules by running `git submodule update --init`")
    exit(1)

app = Application()

app.setup_logging()
app.setup_signal_handling()

app.monitor_networks()

app.wind_down()
